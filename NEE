local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- =============================
-- Конфиг
-- =============================
local WEBHOOK_URL = "https://discord.com/api/webhooks/1417846130619977738/mgmCuOeNpaNOBQddZUtCPaeheSjaBWdLNLfPPg2xk6-533OjiGgbjxwmkKPsQO7TK9ep" -- Вставь сюда Discord/Webhook URL или оставь пустым, чтобы не отправлять

-- Канонические названия брейнротов (с заглавными буквами для вывода)
local CANONICAL_BRAINROT_NAMES = {
	"Los Tralaleritos",
	"Las Tralaleritas",
	"La Cucaracha",
	"Pot Hotspot",
	"Nooo My Hotspot",
	"Los Nooo My Hotspotsitos",
	"Los Hotspotsitos",
	"Los Chicleteiras",
	"Los Tipi Tacos",
	"Los Orcalitos",
	"Los Matteos",
	"Los Bros",
	"Los Noobinis",
	"Los Crocodillitos",
	"Los Tacoritas",
	"Las Vaquitas Saturnitas",
	"La Vacca Saturno Saturnita",
	"Nuclearo Dinossauro",
	"Chimpanzini Bananini",
	"Chimpanzini Spiderini",
	"Frigo Camelo",
	"Elefanto Frigo",
	"Gorillo Watermelondrillo",
	"Rhino Toasterino",
	"Sigma Boy",
	"Sigma Girl",
	"Skibidi",
	"Tung Tung Tung Sahur",
	"Ta Ta Ta Ta Sahur",
	"Job Job Job Sahur",
	"To To To Sahur",
	"Ti Ti Ti Sahur",
	"Esok Sekolah",
	"Tictac Sahur",
	"Tim Cheese",
	"Fluriflura",
	"Talpa Di Fero",
	"Pipi Kiwi",
	"Pipi Potato",
	"Pipi Corni",
	"Pipi Avocado",
	"Gorillo Subwoofero",
	"Gattatino Nyanino",
	"Piccione Macchina",
	"Piccionetta Machina",
	"Orcalero Orcala",
	"Orcalita Orcala",
	"Brr Brr Patapim",
	"Brri Brri Bicus Dicus Bombicus",
	"Bambini Crostini",
	"Bisonte Giuppitere",
	"Torrtuginni Dragonfrutini",
	"Las Sis",
	"La Grande Combinasion",
	"La Supreme Combinasion",
	"Los Combinasionas",
	"Gangster Footera",
	"Bandito Bobritto",
	"Bandito Axolito",
	"Spioniro Golubiro",
	"Bombardiro Crocodilo",
	"Zibra Zubra Zibralini",
	"Tigrilini Watermelini",
	"Carrotini Brainini",
	"Cocofanto Elefanto",
	"Girafa Celestre",
	"Tralalero Tralala",
	"Tralalita Tralala",
	"Trippi Troppi",
	"Trippi Troppi Troppa Trippa",
	"Trenostruzzo Turbo 3000",
	"Trenostruzzo Turbo 4000",
	"Ballerina Cappuccina",
	"Ballerino Lololo",
	"Bulbito Bandito Traktorito",
	"Pakrahmatmamat",
	"Cacasito Satalito",
	"Tartaruga Cisterna",
	"Mastodontico Telepiedone",
	"La Karkerkar Combinasion",
	"Dragon Cannelloni",
	"Spaghetti Tualetti",
	"Karkerkar Kurkur",
	"Dug Dug Dug",
	"Avocadini Antilopini",
	"Avocadini Guffo",
	"Orangutini Ananassini",
	"Blueberrinni Octopusini",
	"Quivioli Ameleonni",
	"Strawberry Elephant",
	"Agarrini La Palini",
	"La Sahur Combinasion",
	"La Extinct Grande",
	"67",
	"Ketchuru and Musturu",
	"Garama and Madundung",
	"Ketupat Kepat",
	"Chicleteira Bicicleteira",
	"Graipuss Medussi",
	"Mariachi Corazoni",
	"Celularcini Viciosini",
	"Los Tungtungtungcitos",
}

-- Разрешенные категории (строки, встречающиеся в именах после Mythic)
local ALLOW_CATEGORY_KEYWORDS = {
	"brainrot god",
	"secret",
	"og",
	"admin",
	"exclusive",
	"taco",
	"craft machine",
	"fuse machine",
	"los ", -- Los/Las
	"las ",
	"ritual",
	"unobtainable",
	"removed",
	"upcoming",
}

-- Запрещенные категории (до Mythic)
local DISALLOW_CATEGORY_KEYWORDS = {
	"common",
	"rare",
	"epic",
	"legendary",
	"mythic",
	"mythic lucky block",
}

-- Путь до баз игроков
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")

-- =============================
-- Утилиты
-- =============================
local function safeLower(str)
	if typeof(str) ~= "string" then
		return ""
	end
	return string.lower(str)
end

local function stringContainsAny(haystack, needles)
	haystack = safeLower(haystack)
	for _, needle in ipairs(needles) do
		if string.find(haystack, needle, 1, true) then
			return true
		end
	end
	return false
end

local function getFullPath(inst)
	local ok, result = pcall(function()
		return inst:GetFullName()
	end)
	return ok and result or inst.Name
end

-- Соберем map lower->canonical
local LOWER_TO_CANON = {}
for _, name in ipairs(CANONICAL_BRAINROT_NAMES) do
	LOWER_TO_CANON[string.lower(name)] = name
end

local function getCanonicalMatch(name)
	local lname = safeLower(name)
	for lowerCanonical, canonical in pairs(LOWER_TO_CANON) do
		if string.find(lname, lowerCanonical, 1, true) then
			return canonical
		end
	end
	return nil
end

local function isAllowedByCategory(name)
	local lname = safeLower(name)
	-- Если содержит запрещенные маркеры и при этом НЕ содержит ни одного разрешенного, то отбрасываем
	local hasDisallow = stringContainsAny(lname, DISALLOW_CATEGORY_KEYWORDS)
	local hasAllow = stringContainsAny(lname, ALLOW_CATEGORY_KEYWORDS)
	if hasDisallow and not hasAllow then
		return false
	end
	return true
end

-- =============================
-- Отправка вебхука (устойчиво)
-- =============================
local function tryExploitRequest(json)
	local req = (syn and syn.request) or (http and http.request) or (http_request) or (request)
	if typeof(req) == "function" then
		local ok, res = pcall(function()
			return req({
				Url = WEBHOOK_URL,
				Method = "POST",
				Headers = { ["Content-Type"] = "application/json" },
				Body = json,
			})
		end)
		if ok then
			if typeof(res) == "table" then
				print(string.format("[BrainrotScanner] Webhook exploit status: %s", tostring(res.StatusCode or res.status or "unknown")))
			end
			return true
		else
			print("[BrainrotScanner] Exploit request failed")
		end
	end
	return false
end

local function tryHttpServiceRequest(json)
	-- Попытка через RequestAsync
	local ok1, res1 = pcall(function()
		return HttpService:RequestAsync({
			Url = WEBHOOK_URL,
			Method = "POST",
			Headers = { ["Content-Type"] = "application/json" },
			Body = json,
		})
	end)
	if ok1 and res1 and res1.Success then
		print(string.format("[BrainrotScanner] Webhook HTTP status: %s", tostring(res1.StatusCode)))
		return true
	end
	-- Попытка через PostAsync
	local ok2, err2 = pcall(function()
		HttpService:PostAsync(WEBHOOK_URL, json, Enum.HttpContentType.ApplicationJson)
	end)
	if ok2 then
		print("[BrainrotScanner] Webhook PostAsync sent")
		return true
	else
		print("[BrainrotScanner] Webhook PostAsync failed")
	end
	return false
end

local function sendWebhook(payload)
	if WEBHOOK_URL == nil or WEBHOOK_URL == "" then
		return
	end
	local json = HttpService:JSONEncode(payload)
	if tryExploitRequest(json) then return end
	tryHttpServiceRequest(json)
end

local function postDiscordSimple(content)
	if WEBHOOK_URL == nil or WEBHOOK_URL == "" then return end
	-- Разбиваем на части по ~1800 символов
	local MAX = 1800
	local i = 1
	while i <= #content do
		local chunk = string.sub(content, i, math.min(i + MAX - 1, #content))
		sendWebhook({ content = "```\n" .. chunk .. "\n```" })
		i = i + MAX
	end
end

-- =============================
-- Детекция брейнротов
-- =============================
local function isBrainrotInstance(inst)
	if not inst then return false end
	local canonical = getCanonicalMatch(inst.Name)
	if not canonical then return false end
	if not isAllowedByCategory(inst.Name) then return false end
	return true
end

local function resolveOwnerNameFromPlot(plot)
	-- Если в структуре плота есть хранение владельца, попробуем достать
	-- На практике часто встречаются значения типа StringValue/IntValue: Owner/OwnerId/UserId и т.п.
	for _, descendant in ipairs(plot:GetDescendants()) do
		if descendant:IsA("StringValue") and stringContainsAny(descendant.Name, {"owner", "username", "user"}) then
			if descendant.Value and #descendant.Value > 0 then
				return descendant.Value
			end
		end
		if descendant:IsA("IntValue") and stringContainsAny(descendant.Name, {"owner", "userid", "user_id"}) then
			local userId = descendant.Value
			if typeof(userId) == "number" and userId > 0 then
				local ok, nameOrErr = pcall(function()
					return Players:GetNameFromUserIdAsync(userId)
				end)
				if ok and typeof(nameOrErr) == "string" then
					return nameOrErr
				end
			end
		end
	end
	return nil
end

-- =============================
-- Сканирование и репортинг (батч)
-- =============================
local function collectBrainrotsInPlot(plot)
	local results = {}
	local seenCanonical = {}
	for _, d in ipairs(plot:GetDescendants()) do
		if isBrainrotInstance(d) then
			local canonical = getCanonicalMatch(d.Name) or d.Name
			if not seenCanonical[canonical] then
				seenCanonical[canonical] = true
				table.insert(results, {
					name = canonical,
					class = d.ClassName,
					path = getFullPath(d),
				})
			end
		end
	end
	return results
end

local function buildPlotSection(plot)
	local ownerName = resolveOwnerNameFromPlot(plot)
	local entries = collectBrainrotsInPlot(plot)
	if #entries == 0 then return nil end
	local lines = {}
	table.insert(lines, string.format("Плот: %s%s | найдено: %d", plot.Name, ownerName and (" (owner: " .. ownerName .. ")") or "", #entries))
	for i, e in ipairs(entries) do
		table.insert(lines, string.format("#%d %s", i, e.name))
	end
	return table.concat(lines, "\n")
end

local function postCombinedAllPlots()
	local sections = {}
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		local section = buildPlotSection(plot)
		if section then
			table.insert(sections, section)
			-- Одновременно печатаем в консоль
			print(section)
			print("")
		end
	end
	if #sections > 0 then
		local body = table.concat(sections, "\n\n")
		postDiscordSimple(body)
	end
end

local function scanAllPlotsOnce()
	postCombinedAllPlots()
end

-- =============================
-- Онлайновый мониторинг (дебаунс)
-- =============================
local connections = {}
local batchScheduled = false
local function scheduleBatch()
	if batchScheduled then return end
	batchScheduled = true
	local delayFn = (typeof(task) == "table" and task.delay) and task.delay or function(sec, fn)
		spawn(function()
			wait(sec)
			fn()
		end)
	end
	delayFn(0.5, function()
		batchScheduled = false
		postCombinedAllPlots()
	end)
end

local function onPlotDescendantAdded(plot, inst)
	if isBrainrotInstance(inst) then
		scheduleBatch()
	end
end

local function attachPlotWatch(plot)
	if connections[plot] then return end
	connections[plot] = plot.DescendantAdded:Connect(function(inst)
		onPlotDescendantAdded(plot, inst)
	end)
end

local function detachPlotWatch(plot)
	if connections[plot] then
		connections[plot]:Disconnect()
		connections[plot] = nil
	end
end

local function watchPlots()
	-- уже существующие
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		attachPlotWatch(plot)
	end
	-- новые и удаленные
	PLOTS_FOLDER.ChildAdded:Connect(function(child)
		attachPlotWatch(child)
		scheduleBatch()
	end)
	PLOTS_FOLDER.ChildRemoved:Connect(function(child)
		detachPlotWatch(child)
		scheduleBatch()
	end)
end

-- =============================
-- Старт
-- =============================
print("[BrainrotScanner] Стартую сканирование брейнротов в Workspace.Plots ...")
scanAllPlotsOnce()
watchPlots()
print("[BrainrotScanner] Мониторинг активирован. Объединенный отчет будет отправляться в один вебхук.")
